---
title: "주문·결제 시스템에서 트랜잭션 경계를 나누는 기준"
date: 2026-02-20
categories: [architecture]
tags: [spring, transaction, backend]
layout: single
sidebar: false
toc: false
classes: wide
---

커머스 시스템에서 가장 많이 고민했던 부분은 트랜잭션 범위였다.
특히 주문 생성 → 결제 승인 → 상태 업데이트는 사용자 입장에서는 하나의 흐름처럼 보이지만, 시스템 관점에서는 책임과 실패 원인이 완전히 다른 단계다.

* 주문 생성: 우리 DB에 “의도(intent)”를 기록하고 재시도 가능한 기준점을 만든다.
* 결제 승인: 외부 PG/카드사와 통신하며 지연·중복·타임아웃 같은 불확실성이 존재한다.
* 상태 로그: 운영·분석·감사를 위해 실패 상황일수록 반드시 남아야 하는 데이터다.

초기에는 모든 로직을 하나의 `REQUIRED` 트랜잭션으로 묶었다.
개발 단계에서는 단순해 보였지만, 운영에서는 문제가 명확하게 드러났다.

* 외부 PG 지연 시 전체 롤백 발생
* 장애 상황일수록 로그 데이터가 남지 않음
* 재시도 기준점이 사라져 운영 추적이 어려움

그래서 트랜잭션 경계를 다시 설계하게 되었고, 핵심 기준은 기술이 아니라 **실패를 어디서 끊어낼 것인가**였다.

---

## 1. 트랜잭션을 나누는 기준

### 1) 실패 원인이 다른 영역은 분리한다

DB 정합성 문제와 외부 시스템 장애는 성격이 완전히 다르다.

* 내부 실패: 재고 차감 실패, 제약조건 위반, 데이터 정합성 오류
* 외부 실패: PG 타임아웃, 네트워크 장애, 중복 승인

이 둘을 하나의 트랜잭션으로 묶으면 외부 불확실성이 내부 데이터까지 롤백시키는 구조가 된다.

트랜잭션은 원자성을 보장하는 도구이지, 전체 비즈니스 흐름을 하나로 묶는 장치가 아니다.

---

### 2) 되돌릴 수 있는 것과 없는 것을 구분한다

DB 트랜잭션은 롤백이 즉시 가능하지만, 결제는 다르다.

* DB: rollback 가능
* 결제: 승인 후 취소, 부분취소, 환불 같은 보상 로직 필요

결제 승인까지 DB 트랜잭션으로 묶으면
“이미 승인된 결제를 DB 롤백으로 되돌리려는” 구조가 되어버린다.

---

### 3) 사용자 요청의 기준점을 먼저 남긴다

사용자가 결제 버튼을 눌렀을 때 가장 먼저 해야 할 일은
“이 요청을 시스템이 인지했다”는 사실을 남기는 것이다.

그래서 주문 생성은 외부 호출과 분리된 짧고 강한 트랜잭션이어야 한다.

---

## 2. 실제로 나눈 트랜잭션 구조

운영에서 가장 안정적으로 동작했던 구조는 다음과 같다.

1. 주문 생성 → REQUIRED
2. 결제 승인 → REQUIRES_NEW
3. 상태 로그 기록 → 별도 트랜잭션

핵심은 기술 선택이 아니라 실패 격리다.

---

## 3. 주문 생성 — REQUIRED

주문 생성은 내부 데이터 정합성을 보장해야 하는 최소 단위다.

이 단계에서 확정하는 것들:

* 주문 번호(order_id)
* 결제 금액 스냅샷
* 배송지/쿠폰/상품 정보
* 멱등키(idempotency key)
* 초기 상태(`CREATED`, `PAYMENT_PENDING` 등)

주문이 먼저 생성되어야 결제 실패 시에도 재시도 기준점이 남는다.

만약 결제를 먼저 하고 주문을 나중에 만든다면
“결제는 됐는데 주문이 없는” 상황이 발생할 수 있다.

---

## 4. 결제 승인 — REQUIRES_NEW (실패 격리)

결제는 외부 시스템과 통신한다.

* 타임아웃
* 네트워크 장애
* 중복 요청
* 승인 성공 후 내부 처리 실패

이런 불확실성을 주문 트랜잭션에 묶으면 DB 커넥션을 오래 점유하게 되고, 장애가 내부 데이터까지 영향을 준다.

그래서 결제는 `REQUIRES_NEW`로 분리했다.

### 기대 효과

* 결제 실패가 주문 데이터까지 롤백시키지 않음
* 상태를 명확하게 표현 가능 (`PAYMENT_FAILED`, `PAYMENT_UNKNOWN`)
* 장애 상황에서도 주문이 남아 추적 가능

---

### REQUIRES_NEW를 사용할 때 반드시 필요한 것

#### 1) 상태 머신(State Machine)

주문 상태를 명확히 정의해야 한다.

* CREATED
* PAYMENT_PENDING
* PAYMENT_SUCCESS
* PAYMENT_FAILED
* PAYMENT_UNKNOWN
* COMPLETED

특정 상태에서만 다음 상태로 전이되도록 제한해야 한다.

---

#### 2) 멱등 처리(Idempotency)

결제 재시도에서 중복 승인을 막기 위해 다음이 필요하다.

* payment_attempt_id 관리
* unique constraint
* PG idempotency 지원 활용

---

#### 3) 승인 성공 후 DB 반영 실패 대비

가장 위험한 케이스는 다음이다.

* PG 승인 성공
* 내부 DB 반영 실패

이를 대비해 보통 아래 전략을 사용한다.

* 승인 결과를 append-only 테이블에 먼저 저장
* Outbox 패턴으로 이벤트 발행 후 비동기 반영

---

## 5. 상태 로그 — 별도 트랜잭션

로그는 성공보다 실패 상황에서 더 중요하다.

비즈니스 트랜잭션과 묶으면 실패할수록 기록이 사라진다.

분리 대상 예시:

* 결제 요청/응답 전문
* 상태 전이 이력
* latency / timeout 정보
* trace id / request id
* 감사 로그

구현 방식은 다양하다.

* REQUIRES_NEW 로그 트랜잭션
* 비동기 로깅
* Outbox + 이벤트 처리

---

## 6. 트랜잭션을 나눴을 때 얻은 운영 효과

### 1) 장애 격리

PG 장애가 발생해도 주문은 남는다.

---

### 2) 재시도 설계 가능

주문을 기준으로 결제 재시도 정책을 만들 수 있다.

---

### 3) CS 대응 효율 증가

상태와 이력이 남아 있어 장애 분석 시간이 줄어든다.

---

### 4) DB 병목 감소

외부 호출이 DB 트랜잭션 밖으로 나가면서
커넥션 점유 시간이 크게 줄어든다.

---

## 7. 결론

트랜잭션 설계에서 중요한 건 기술 선택 자체가 아니다.

* 어디서 실패를 끊어낼 것인가
* 실패 후 어떤 상태로 남길 것인가
* 재시도와 보상 로직이 가능한 구조인가

결제 도메인에서는 특히
“외부 실패가 내부 데이터를 망치지 않도록” 경계를 나누는 것이 핵심이었다.

아키텍처 관점에서 트랜잭션은 단순한 기술 옵션이 아니라
**시스템의 실패 전략을 설계하는 도구**에 가깝다.
